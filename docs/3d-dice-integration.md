# 3D Dice Integration Research

**Date:** 2025-01-09
**Status:** Research Complete - Ready for Implementation Decision

## Executive Summary

This document outlines research into integrating 3D dice rolling into the Nimble character sheet application. The primary requirement is to **use our existing local dice service results** and visualize them with 3D animations, rather than relying on external services to generate random results.

**Recommendation:** Use `@3d-dice/dice-box` for self-hosted 3D dice with full control over results.

---

## Requirements

1. **Maintain Control**: Our local `DiceService` must remain the authoritative source for dice results
2. **Consistency**: Same RNG, same critical hit logic, same advantage/disadvantage handling
3. **Offline Support**: 3D dice should work without internet connection
4. **Trust**: Players should know results aren't from third-party service
5. **Integration**: Seamless integration with existing dice rolling flow

---

## Solutions Evaluated

### 1. dddice.com (Cloud-Based)

**What it is:**
- Professional cloud-based 3D dice rolling service
- Provides SDK for integration
- Includes multiplayer room support
- Beautiful physics and rendering

**Pros:**
- ✅ Professional quality animations
- ✅ Multiplayer room support built-in
- ✅ Smaller bundle size (SDK is lightweight)
- ✅ Theme marketplace with custom dice sets
- ✅ Streaming integration (OBS, Twitch)
- ✅ Well-maintained with active support

**Cons:**
- ❌ **Does not support external/predetermined results** (researched, not documented)
- ❌ Requires API key and external service dependency
- ❌ Won't work offline
- ❌ Usage limits and potential costs at scale
- ❌ Results generated by third-party service
- ❌ Network latency for each roll

**Technical Details:**
- Package: `dddice-js` (npm)
- Repository: https://github.com/dddice/dddice-js
- Documentation: https://docs.dddice.com
- Requires account signup and API key
- Supports room-based multiplayer

**Use Case:** Best if you want third-party to handle RNG and don't mind external dependency.

---

### 2. @3d-dice/dice-box (Self-Hosted) ⭐ **RECOMMENDED**

**What it is:**
- Modern, actively maintained fork of the original dice-box library
- WebGL-based 3D dice roller that runs entirely in browser
- Built on Three.js and Cannon.js (physics)
- TypeScript support

**Pros:**
- ✅ **Supports external/predetermined results** ⭐ (Key requirement!)
- ✅ Fully self-hosted - no external dependencies
- ✅ Works completely offline
- ✅ No API keys or accounts needed
- ✅ Open source (MIT license)
- ✅ Complete control over physics and rendering
- ✅ TypeScript definitions included
- ✅ Active maintenance and updates

**Cons:**
- ⚠️ Larger bundle size (~500KB minified)
- ⚠️ Requires WebGL support (most modern browsers)
- ⚠️ More setup complexity
- ⚠️ Need to handle physics engine edge cases
- ⚠️ Manual theme creation (no marketplace)

**Technical Details:**
- Package: `@3d-dice/dice-box` (npm)
- Repository: https://github.com/3d-dice/dice-box
- Documentation: https://3d-dice.github.io/dice-box/
- Bundle size: ~500KB (can be code-split)
- Supports: d4, d6, d8, d10, d12, d20, d100

**Example Usage:**
```typescript
import DiceBox from '@3d-dice/dice-box';

const diceBox = new DiceBox('#dice-canvas', {
  assetPath: '/assets/dice-box/',
  theme: 'default'
});

// Roll with our own predetermined results
await diceBox.roll([
  { qty: 1, sides: 20, value: 15 }, // Force d20 to show 15
  { qty: 2, sides: 6, value: [3, 5] } // Force 2d6 to show 3 and 5
]);
```

**Use Case:** Best for maintaining full control with self-hosted solution.

---

### 3. dice-ui (CSS-Based)

**What it is:**
- Pure CSS 3D dice animation
- No JavaScript physics engine
- Lightweight alternative

**Pros:**
- ✅ Very small bundle size
- ✅ No WebGL required
- ✅ Simple integration

**Cons:**
- ❌ Less realistic physics
- ❌ Limited dice types
- ❌ Basic animations
- ❌ Not widely used/maintained

**Use Case:** Only consider if bundle size is critical concern and realism isn't important.

---

### 4. Roll20 3D Dice (Legacy)

**What it is:**
- Open source dice roller from Roll20
- Canvas-based rendering

**Pros:**
- ✅ Battle-tested in production
- ✅ Realistic physics

**Cons:**
- ❌ Older codebase (jQuery era)
- ❌ Harder to integrate with modern frameworks
- ❌ Less actively maintained
- ❌ No TypeScript support

**Use Case:** Not recommended for new projects.

---

## Recommended Approach: @3d-dice/dice-box

### Architecture

```
User Triggers Roll
      ↓
DiceService.roll()
(generates result with our RNG)
      ↓
Check Settings: 3D Enabled?
      ↓                 ↓
     YES               NO
      ↓                 ↓
DiceBoxService         Skip 3D
(animate with
predetermined
results)
      ↓
Wait for animation
      ↓
Update Activity Log
(with our original result)
```

### Implementation Plan

#### Phase 1: Setup (Estimated: 1-2 hours)

1. **Install Package**
   ```bash
   npm install @3d-dice/dice-box
   ```

2. **Download Assets**
   - Download dice models and textures
   - Place in `public/assets/dice-box/`
   - Configure asset path

3. **Update Settings Schema** (`lib/schemas/settings.ts`)
   ```typescript
   export const SettingsSchema = z.object({
     // ... existing settings
     enable3DDice: z.boolean().default(false),
     diceTheme: z.string().default('default'), // 'default', 'smooth', 'gemstone'
     diceSize: z.enum(['small', 'medium', 'large']).default('medium'),
   });
   ```

#### Phase 2: Service Layer (Estimated: 3-4 hours)

4. **Create DiceBoxService** (`lib/services/dice-box-service.ts`)
   ```typescript
   class DiceBoxService {
     private diceBox: DiceBox | null = null;

     async initialize(canvasId: string): Promise<void>
     async rollDiceWithResults(rolls: DiceRoll[], results: number[]): Promise<void>
     async cleanup(): Promise<void>
     isSupported(): boolean // Check WebGL support
   }
   ```

5. **Integrate with DiceService** (`lib/services/dice-service.ts`)
   ```typescript
   async roll(notation: string, options: RollOptions): Promise<RollResult> {
     // 1. Generate result using our existing logic
     const result = this.generateResult(notation, options);

     // 2. If 3D enabled, animate the result
     const settings = await getSettingsService().getSettings();
     if (settings.enable3DDice && diceBoxService.isSupported()) {
       await diceBoxService.rollDiceWithResults(
         parsedDice,
         result.diceRolls.map(r => r.value)
       );
     }

     // 3. Return our authoritative result
     return result;
   }
   ```

#### Phase 3: UI Integration (Estimated: 2-3 hours)

6. **Add 3D Dice Canvas** (`components/dice-canvas.tsx`)
   ```typescript
   // Overlay canvas that appears when rolling
   // Fades in during roll, fades out after animation
   export function DiceCanvas() {
     return (
       <canvas
         id="dice-canvas"
         className="fixed inset-0 z-50 pointer-events-none"
       />
     );
   }
   ```

7. **Update Settings Panel** (`components/settings-panel.tsx`)
   ```typescript
   // Add toggle for 3D dice
   // Add theme selector
   // Add size selector
   // Show WebGL compatibility warning if not supported
   ```

8. **Add to Main Layout** (`app/page.tsx`)
   ```typescript
   // Add DiceCanvas component
   // Initialize DiceBoxService on mount
   ```

#### Phase 4: Polish & Testing (Estimated: 2-3 hours)

9. **Test Coverage**
   - Test all dice types (d4, d6, d8, d10, d12, d20, d100)
   - Test advantage/disadvantage (multiple dice of same type)
   - Test multi-die rolls (2d6, 3d8, etc.)
   - Test with 3D enabled and disabled
   - Test WebGL fallback
   - Test theme switching
   - Test on mobile devices

10. **Error Handling**
    - Graceful fallback when WebGL not supported
    - Handle animation failures
    - Show loading state during initialization
    - Proper cleanup on component unmount

11. **Performance Optimization**
    - Code-split dice-box to reduce initial bundle
    - Lazy load assets
    - Cleanup physics engine when not in use
    - Optimize for mobile devices

---

## Alternative: Hybrid dddice Approach

If you prefer dddice's professional quality despite lack of external result support:

### Option A: Cosmetic Animation Only

```typescript
// Generate result with our DiceService
const ourResult = await diceService.roll('1d20+5');

// Show result immediately
activityLog.add(ourResult);

// Simultaneously: trigger dddice animation (cosmetic only)
if (settings.enable3DDice) {
  dddice.roll('1d20').then(dddiceResult => {
    // Ignore dddice result, already showed ours
  });
}
```

**Pros:**
- Beautiful animations
- Smaller bundle size
- Professional quality

**Cons:**
- Animation doesn't match actual result (immersion breaking)
- Requires API key and internet
- Animation is purely cosmetic

### Option B: dddice for Enhanced Mode Only

```typescript
// Default mode: our DiceService
// "Enhanced Visuals" mode: use dddice results

if (settings.enhancedVisuals && online) {
  result = await dddice.roll(notation);
} else {
  result = await diceService.roll(notation);
}
```

**Pros:**
- Optional enhancement
- Falls back gracefully

**Cons:**
- Inconsistent RNG source
- Different game feel in different modes
- Trust issues with enhanced mode

---

## Bundle Size Comparison

| Solution | Bundle Size (min+gzip) | External Dependency |
|----------|----------------------|---------------------|
| dddice.com | ~50KB | Yes (API) |
| @3d-dice/dice-box | ~500KB | No |
| dice-ui | ~10KB | No |
| Current (2D only) | 0KB | No |

**Note:** dice-box can be code-split and lazy loaded to reduce initial bundle.

---

## Multiplayer Considerations

### With dice-box (Self-Hosted)
- 3D animation is **local only** by default
- Can sync results via existing Pusher integration
- Other players see results in activity log, not 3D animation
- Could implement shared WebSocket for synchronized 3D (advanced)

### With dddice (Cloud)
- Built-in multiplayer rooms
- All players in room see same 3D animation
- Automatic synchronization
- Would integrate well with existing activity sharing feature

---

## Mobile Considerations

### Performance
- WebGL 3D dice may be heavy on older mobile devices
- Battery consumption concerns
- Should default to **disabled on mobile**, allow opt-in
- Consider simplified physics on mobile

### Implementation
```typescript
const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const defaultEnable3D = !isMobile; // Default off on mobile
```

---

## Cost Analysis

### dice-box (Self-Hosted)
- **Cost:** $0 (open source, MIT license)
- **Maintenance:** Minimal (stable library)
- **Scaling:** No limits (runs client-side)

### dddice (Cloud)
- **Free Tier:** Limited rolls per month
- **Paid Tiers:** Starting at $5/month for indie developers
- **Enterprise:** Custom pricing
- **Scaling:** Costs increase with usage

---

## Security & Privacy

### dice-box
- ✅ All computation client-side
- ✅ No data sent to external services
- ✅ Complete privacy
- ✅ Works offline

### dddice
- ⚠️ Rolls sent to external API
- ⚠️ Requires API key (exposed in client)
- ⚠️ Usage tracked by dddice
- ❌ Requires internet connection

---

## Final Recommendation

**Use `@3d-dice/dice-box` for the following reasons:**

1. ✅ **Meets primary requirement**: Supports external/predetermined results
2. ✅ **Self-hosted**: No external dependencies or API keys
3. ✅ **Offline-first**: Aligns with app's offline architecture
4. ✅ **Privacy**: No data sent to third parties
5. ✅ **Cost**: Free and open source
6. ✅ **Control**: Full control over physics, rendering, and results
7. ✅ **TypeScript**: First-class TypeScript support

**Trade-offs:**
- Larger bundle size (~500KB) - mitigated with code-splitting
- More setup complexity - one-time cost
- Manual theme creation - acceptable for MVP

**Implementation Timeline:**
- **Phase 1 (Setup):** 1-2 hours
- **Phase 2 (Services):** 3-4 hours
- **Phase 3 (UI):** 2-3 hours
- **Phase 4 (Testing):** 2-3 hours
- **Total:** 8-12 hours

---

## Next Steps

1. **Decision**: Confirm dice-box as chosen solution
2. **Spike**: Create proof-of-concept with single d20 roll
3. **Implement**: Follow implementation plan above
4. **Test**: Comprehensive testing across devices
5. **Deploy**: Feature flag for gradual rollout

---

## References

- dice-box Repository: https://github.com/3d-dice/dice-box
- dice-box Documentation: https://3d-dice.github.io/dice-box/
- dddice Documentation: https://docs.dddice.com
- dddice Repository: https://github.com/dddice/dddice-js
- Three.js Documentation: https://threejs.org/docs/
- Cannon.js Physics: https://github.com/schteppe/cannon.js

---

## Appendix: Example Integration Code

### DiceBoxService Implementation

```typescript
// lib/services/dice-box-service.ts
import DiceBox from '@3d-dice/dice-box';

export class DiceBoxService {
  private static instance: DiceBoxService;
  private diceBox: DiceBox | null = null;
  private initialized = false;

  static getInstance(): DiceBoxService {
    if (!DiceBoxService.instance) {
      DiceBoxService.instance = new DiceBoxService();
    }
    return DiceBoxService.instance;
  }

  async initialize(canvasSelector: string): Promise<void> {
    if (this.initialized) return;

    // Check WebGL support
    if (!this.isWebGLSupported()) {
      console.warn('WebGL not supported, 3D dice disabled');
      return;
    }

    try {
      this.diceBox = new DiceBox(canvasSelector, {
        assetPath: '/assets/dice-box/',
        theme: 'default',
        gravity: 1,
        mass: 1,
        friction: 0.8,
        restitution: 0.5,
        angularDamping: 0.4,
        linearDamping: 0.5,
      });

      await this.diceBox.init();
      this.initialized = true;
    } catch (error) {
      console.error('Failed to initialize DiceBox:', error);
      this.diceBox = null;
    }
  }

  async rollWithPredeterminedResults(
    dice: Array<{ sides: number; qty: number }>,
    results: number[]
  ): Promise<void> {
    if (!this.diceBox || !this.initialized) {
      console.warn('DiceBox not initialized');
      return;
    }

    // Build roll notation with predetermined values
    const rollNotation = dice.map((die, index) => ({
      qty: die.qty,
      sides: die.sides,
      value: results.slice(
        dice.slice(0, index).reduce((sum, d) => sum + d.qty, 0),
        dice.slice(0, index + 1).reduce((sum, d) => sum + d.qty, 0)
      ),
    }));

    await this.diceBox.roll(rollNotation);
  }

  isWebGLSupported(): boolean {
    try {
      const canvas = document.createElement('canvas');
      return !!(
        window.WebGLRenderingContext &&
        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
      );
    } catch (e) {
      return false;
    }
  }

  async cleanup(): Promise<void> {
    if (this.diceBox) {
      await this.diceBox.clear();
      this.diceBox = null;
      this.initialized = false;
    }
  }
}

export const diceBoxService = DiceBoxService.getInstance();
```

### Integration with Existing DiceService

```typescript
// lib/services/dice-service.ts (additions)
import { diceBoxService } from './dice-box-service';
import { getSettingsService } from './service-factory';

export class DiceService {
  // ... existing code

  async rollWithVisualization(
    notation: string,
    options: RollOptions = {}
  ): Promise<RollResult> {
    // 1. Parse notation
    const parsed = this.parseNotation(notation);

    // 2. Generate result with our RNG
    const result = this.generateResult(parsed, options);

    // 3. Check if 3D visualization enabled
    const settings = await getSettingsService().getSettings();

    if (settings.enable3DDice) {
      try {
        // 4. Trigger 3D animation with our predetermined results
        await diceBoxService.rollWithPredeterminedResults(
          parsed.dice,
          result.diceRolls.map(r => r.value)
        );
      } catch (error) {
        console.warn('3D dice visualization failed, continuing with 2D:', error);
      }
    }

    // 5. Return our authoritative result
    return result;
  }
}
```

---

**Document Version:** 1.0
**Last Updated:** 2025-01-09
**Author:** Research conducted by Claude
**Status:** Ready for Implementation Decision
